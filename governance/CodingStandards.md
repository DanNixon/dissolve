# Coding Standards for Disordered Materials Software Projects

## Fortran Standards (Taken from Fortran 90 Standards for JULES)
 - Use the Fortran 90 free format syntax.
 - Indent blocks by 2 characters. Where possible, comments should be indented with the code within a block.
 - Use space and blank lines where appropriate to format your code to improve readability (use genuine spaces rather than tabs, as the tab character is not in the Fortran character set). For example:
 - 
```fortran
DO i = 1, n
  a(i)%c = 10 * i / n
END DO

IF (this == that) THEN
  distance = 0
  time     = 0
END IF
``` 

- Try to confine your line width to 80 characters. This means that your code can be viewed easily in any editor on any screen, and can be printed easily on A4 paper.
- Line up your statements, where appropriate, to improve readability. For example:
```fortran
REAL, INTENT(IN   ) ::    my_in(:)
REAL, INTENT(INOUT) :: my_inout(:)
REAL, INTENT(  OUT) ::   my_out(:)

! ...

CHARACTER(LEN=256) :: my_char

! ...

my_char                                                 &
    =  'This is a very very very very very very very '  &
    // 'very very very very very very very very very '  &
    // 'long character assignment'
```
- Short and simple Fortran statements are easier to read and understand than long and complex ones. Where possible, avoid using continuation lines in a statement.
- Avoid putting multiple statements on the same line. It is not good for readability.
- Each program unit (module, subroutine, function etc.) should follow a structure similar to the templates supplied in [Standard code templates](http://jules-lsm.github.io/coding_standards/standard_code_templates/index.html). The intended behaviour of the unit should be clearly described in the header.
- Comments should start with a single ! at beginning of the line. A blank line should be left before (but not after) the comment line. The only exception is for one line comments which can be indented within the code or placed after the statement.
- Each subroutine, function and module should be in a separate file. Modules may be used to group related variables, subroutines and functions.
## C++ Standards (Taken from Mantid C++ Standards)
### Classes and Namespaces
- There should be only one class or namespace declared in each header file. This recommendation should only be relaxed where classes are closely tied together.
- There should be only one class or namespace defined per body file (unless classes are closely tied as in (1) above). All the definitions for that class/namespace should be in the one file (unless this yields a source file that is unmanageably large).
- Data members should be private. Access to data from other classes should only be through protected or public methods (or by ‘friends’, but see item 8). Inside a large class, consider reserving direct access to private data members for a smaller manageable core of member functions.
- All constructors for a class must initialise all its member variables that do not have a default constructor (including primitive and pointer types).
- All base classes must have a virtual destructor.
- This may be disregarded only in exceptional circumstances when the overhead of a virtual-table would significantly affect performance. Such a class must not be subclassed, and must be adequately commented to warn other developers against subclassing the class.
- In addition, it is recommended that where possible, programming techniques are used to prevent inheritance of classes with a non-virtual destructor. While comments may suffice they can easily be ignored or misunderstood, particularly by inexperienced developers
- Classes’ constructors and destructors must not call their own virtual member functions, directly or indirectly. (C++ does not resolve such function calls polymorphically.)
- Do not define special members functions when they would be identical to those automatically generated by the compiler. Use = delete to remove invalid compiler-generated versions. Consider following the rule-of-zero and writing an additional class for resource management.
- The use of friend should be avoided and its use requires justification. As an exception, overloads of the << and >> operators for serialising the class may be declared as friend.
- Use of multiple inheritance should be restricted to cases in which the second and subsequent base classes are all interfaces. (An interface in this context is a class consisting only of pure virtual functions.).
- Virtual inheritance should only be used when the base class involved is an interface.
Unions and bitfields should only be used where essential for performance, or where required for interfacing with a third party library.
### Functions and Variables
- Variables, functions parameters, and function return values must have explicit types (no defaulting to int).
- A function declaration should not use void to indicate an empty parameter list.
- Parameters in function prototypes should include names, not just their types. For example, use void eraseRange(int nFirst, int nLast); rather than void eraseRange(int, int); as this improves self-documentation.
- Non-static member functions should be declared const if logically they do not alter the state of the class instance.
- Simple accessor functions may be inline (e.g. inline int getCount() const { return m_nCount;}). Otherwise, inline functions should be avoided unless essential for performance.
- Operators should be overloaded sparingly. Operator overloads should behave in accordance with the semantics of the operator as applied to primitive types, or according to established conventions (e.g. << and >> for serialisation).
- ‘Magic numbers’ must not be used in the code. Constants and enumerations must be used instead.
### Expressions and Statements
- Integers should not be cast to Booleans. For example, prefer if (x != 0) rather than if(x)
The new style type casting must be used in place of the old C style type casts. If casting up or down an inheritance hierarchy, use dynamic_cast (which performs a run-time type check) rather than static_cast.
- Function calls with side effects, and the ++/--/assignment operators, should only be called as a standalone statement rather than embedded inside an expression.
	- It is permissible, although discouraged, to have a function call with side effects as the right-operand of && or ||. Any such instances must be commented in detail to alert other developers to the fact that the function is not always called.
- A for loop should only have one control variable, and should not modify it in the body.
- switch statements must include a default clause, even if only to catch errors.
- Each case of a switch statement must either end with a break/return, or contain a clear comment to alert other developers to the fact that execution will fall through to the next case. Multiple case labels (with no code between them) are, however, permitted for the same block of code.
- goto must be avoided. When there is a need to break out of two or more nested loops in one go, the loops should be moved to a separate function where ‘return’ can be used instead.
## Comments
- Sufficient commenting (to the level mandated by this document) of a piece of code must be performed at the same time as the code is written. It must not be put off until the end of development. When code is updated, all relevant comments must be updated as well (including those in the header).
- ‘Dead code’ must not be kept in the source code. (‘Dead code’ here means code that has been commented out or unconditionally suppressed in some other way, for example using #if 0 preprocessor directives.)
	- In the (rare) instances that dead code would serve an important documentation purpose for ongoing development, the dead code must be placed in an external location and may be referenced from the ‘live’ source code.
- Comments must be indented to the same level as the code to which they refer.
- The language used in comments must be professional and to the point. Flippant or derogatory remarks must be avoided.
- The collection of comments in a function must, on its own, be sufficient that a competent C++ developer can pick up the function for subsequent development.
- Comments on a single line should use // rather than /* … */.
- No code block should exceed 20 statement lines without a comment of some sort. In general all code should contain 15% comment lines.
- The style of the comments is not mandated here. However the following are general recommendations:
	- Comments should always be used to describe potential “difficult” sections of code utilising, for example, special algorithms
	- Comments should be used in particular to explain branch conditions in if ... else and switch { case ...-like statements
	- Comments should be written at a higher level of abstraction than the code to which they pertain, rather than merely restating it
## Error Handling
The type of error handling needed depends on what the code is doing. In daemon / service type of program almost nothing may be allowed to cause the process to terminate, whereas in some utility programs it may be acceptable to terminate for many error conditions. This is a design issue and the strictness of application of the following should take into account the use of the code.

- The developer should identify all errors that can be generated by a function and ensure that they are dealt with appropriately at some point in the system. This may be within the function itself or higher up in the call stack.
- All exceptions must be caught and handled properly. (This may include terminating the program cleanly, for instance if no more memory can be allocated.)
- Public functions should check their input parameters before using them. This checking may be made using the assert() macro or similar mechanism, and so only checked in the debug build, in which case comprehensive testing must be performed of the release build.
- All error status values returned from a function call must be checked or explicitly ignored. (To explicitly ignore a function call’s return value cast it to void, e.g. (void) f(a, b);)
- When using dynamic_cast on a pointer, a check must be made that the result is not null (i.e. that the cast was successful).
- Destructors must not throw any exceptions, directly or indirectly. (Exceptions encountered while calling destructors during stack unwinding from an earlier exception will cause immediate program termination.)
- Where the language permits it, and where the occurrence of errors can be identified at coding time (e.g. opening a file), errors should be trapped on an individual basis, rather than using a catch-all error handler.
- Error messages displayed to the user must be understandable and informative. They must suggest an action to the user, which will resolve the problem, for example:
	- No further action is required.
	- Check the XYZ input data and then repeat the process.
	- Contact the system administrator.## Python Standards